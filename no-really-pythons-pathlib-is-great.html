<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="./theme/css/elegant.prod.9e9d5ce754.css" media="screen">
        <link rel="stylesheet" type="text/css" href="./theme/css/custom.css" media="screen">

        <link rel="dns-prefetch" href="//fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>

        <meta name="google-site-verification" content="<meta name='google-site-verification' content='N5QEPRj-LpgoEY0Hf3uVMmZq8kjDwTFjd54IgvLmRBc' />" />        <meta name="author" content="Redowan Delowar" />

        <meta name="description" content="When I first encountered Python&#39;s pathlib module for path manipulation, I brushed it aside assuming it to be just an OOP way of doing what os.path already does quite well. The official doc also dubs it as the Object-oriented filesystem paths. However, back in 2019 when this ticket confirmed …
" />
        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="Python, python, " />

<meta property="og:title" content="No really, Python&#39;s pathlib is great "/>
<meta property="og:url" content="./no-really-pythons-pathlib-is-great.html" />
<meta property="og:description" content="When I first encountered Python&#39;s pathlib module for path manipulation, I brushed it aside assuming it to be just an OOP way of doing what os.path already does quite well. The official doc also dubs it as the Object-oriented filesystem paths. However, back in 2019 when this ticket confirmed …" />
<meta property="og:site_name" content="Redowan&#39;s Reflections" />
<meta property="og:article:author" content="Redowan Delowar" />
<meta property="og:article:published_time" content="2020-04-13T00:00:00+06:00" />
<meta name="twitter:title" content="No really, Python&#39;s pathlib is great ">
<meta name="twitter:description" content="When I first encountered Python&#39;s pathlib module for path manipulation, I brushed it aside assuming it to be just an OOP way of doing what os.path already does quite well. The official doc also dubs it as the Object-oriented filesystem paths. However, back in 2019 when this ticket confirmed …">
<meta property="og:image" content="https://user-images.githubusercontent.com/30027932/149235389-c6b85b40-5515-4de4-a922-7b0f91efd0cf.png" />
<meta name="twitter:image" content="https://user-images.githubusercontent.com/30027932/149235389-c6b85b40-5515-4de4-a922-7b0f91efd0cf.png" >

        <title>No really, Python&#39;s pathlib is great  · Redowan&#39;s Reflections
</title>
        <link href="https://rednafi.github.io/reflections/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Redowan&#39;s Reflections - Full Atom Feed" />

<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
     m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-217287505-1', 'auto');
    ga('send', 'pageview');
</script>


    </head>
    <body>
        <div id="content">
            <div class="navbar navbar-static-top">
                <div class="navbar-inner">
                    <div class="container-fluid">
                        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </a>
                        <a class="brand" href="./"><span class=site-name>Redowan's Reflections</span></a>
                        <div class="nav-collapse collapse">
                            <ul class="nav pull-right top-menu">
                                <li >
                                    <a href=
                                       .
                                    >Home</a>
                                </li>
                                <li ><a href="./pages/contact.html">Contact</a></li>
                                <li ><a href="./categories.html">Categories</a></li>
                                <li ><a href="./tags.html">Tags</a></li>
                                <li ><a href="./archives.html">Archives</a></li>
                                <li>
                                  <form action="https://www.google.com/search" class="navbar-search" method="get" name="searchform" target="_blank">
                                    <input name="sitesearch" type="hidden"
                                    value="rednafi.github.io/reflections">
                                    <input autocomplete="on" class="search-query" name="q" placeholder="Search"
                                    required="required"  type="text">
                                    <input type="submit" value="Search" style="visibility: hidden;" /></form>
                                  </form>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="container-fluid">
                <div class="row-fluid">
                    <div class="span1"></div>
                    <div class="span10">
<article itemscope>
<div class="row-fluid">
    <header class="page-header span10 offset2">
        <h1>
            <a href="./no-really-pythons-pathlib-is-great.html">
                No really, Python's pathlib is great
            </a>
        </h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">
            
            <p>When I first encountered Python's <code>pathlib</code> module for path manipulation, I brushed it
aside assuming it to be just an OOP way of doing what <code>os.path</code> already does quite well.
The official doc also dubs it as the <code>Object-oriented filesystem paths</code>. However, back
in 2019 when <a href="https://code.djangoproject.com/ticket/29983">this</a> ticket confirmed that
Django was replacing <code>os.path</code> with <code>pathlib</code>, I got curious.</p>
<p>The <code>os.path</code> module has always been the de facto standard for working with paths in
Python. But the API can feel massive as it performs a plethora of other loosely coupled
system related jobs. I've to look things up constantly even to perform some of the most
basic tasks like joining multiple paths, listing all the files in a folder having a
particular extension, opening multiple files in a directory etc. The <code>pathlib</code> module
can do nearly everything that <code>os.path</code> offers and comes with some additional cherries
on top.</p>
<h2>Problem with Python's path handling</h2>
<p>Traditionally, Python has represented file paths as regular text strings. So far, using
paths as strings with <code>os.path</code> module has been adequate although a bit cumbersome.
However, paths are not actually strings and this has necessitated the usage of multiple
modules to provide disparate functionalities that are scattered all around the standard
library, including libraries like <code>os</code>, <code>glob</code>, and <code>shutil</code>. The following code uses
three modules just to copy multiple python files from current directory to another
directory called <code>src</code>.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shutil</span>

<span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*.py&quot;</span><span class="p">):</span>
    <span class="n">new_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
    <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">new_path</span><span class="p">)</span>
</code></pre></div>

<p>The above pattern can get complicated fairly quickly and you have to know or look for
specific modules and methods in a large search space to perform your path manipulations.
Let's have a look at a few more examples of performing the same tasks using <code>os.path</code>
and <code>pathlib</code> modules.</p>
<h2>Joining &amp; creating new paths</h2>
<p>Say you want to achieve the following goals:</p>
<ul>
<li>There is a file named <code>file.txt</code> in your current directory and you want to create the
path for another file named <code>file_another.txt</code> in the same directory</li>
<li>Then you want to save the absolute path of <code>file_another.txt</code> in a new variable.</li>
</ul>
<p>Let's see how you'd usually do this via the <code>os</code> module.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">abspath</span><span class="p">,</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">join</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="n">abspath</span><span class="p">(</span><span class="s2">&quot;./file.txt&quot;</span><span class="p">)</span>
<span class="n">base_dir</span> <span class="o">=</span> <span class="n">dirname</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
<span class="n">file_another_path</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="s2">&quot;file_another.txt&quot;</span><span class="p">)</span>
</code></pre></div>

<p>The variables <code>file_path</code>, <code>base_dir</code>, <code>file_another_path</code> look like this on my machine:</p>
<div class="highlight"><pre><span></span><code><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;file_path:&quot;</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;base_dir:&quot;</span><span class="p">,</span> <span class="n">base_dir</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;file_another_path:&quot;</span><span class="p">,</span> <span class="n">file_another_path</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; file_path: /home/rednafi/code/demo/file.txt
&gt;&gt;&gt; base_dir: /home/rednafi/code/demo
&gt;&gt;&gt; file_another_path: /home/rednafi/code/demo/file_another.txt
</code></pre></div>

<p>You can use the usual string methods to transform the paths but generally, that's not a
good idea. So, instead of joining two paths with <code>+</code> like regular strings, you should
use <code>os.path.join()</code> to join the components of a path. This is because different
operating systems do not define paths in the same way. Windows uses <code>"\"</code> while Mac and
*nix based OSes use <code>"/"</code> as a separator.  Joining with <code>os.path.join()</code> ensures correct
path separator on the corresponding operating system. Pathlib module uses <code>"/"</code> operator
overloading and make this a little less painful.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;file.txt&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
<span class="n">base_dir</span> <span class="o">=</span> <span class="n">file_path</span><span class="o">.</span><span class="n">parent</span>
<span class="n">file_another_path</span> <span class="o">=</span> <span class="n">base_dir</span> <span class="o">/</span> <span class="s2">&quot;another_file.txt&quot;</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;file_path:&quot;</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;base_dir:&quot;</span><span class="p">,</span> <span class="n">base_dir</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;file_another_path:&quot;</span><span class="p">,</span> <span class="n">file_another_path</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; file_path: /home/rednafi/code/demo/file.txt
&gt;&gt;&gt; base_dir: /home/rednafi/code/demo
&gt;&gt;&gt; file_another_path: /home/rednafi/code/demo/file_another.txt
</code></pre></div>

<p>The <code>resolve</code> method finds out the absolute path of the file. From there you can use the
<code>parent</code> method to find out the base directory and add the <code>another_file.txt</code>
accordingly.</p>
<h2>Making directories &amp; renaming files</h2>
<p>Here’s a piece of code that:</p>
<ul>
<li>Tries to make a <code>src/stuff/</code> directory when it already exists</li>
<li>Renames a file in the <code>src</code> directory called  <code>.config</code> to <code>.stuffconfig</code>:</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span>

<span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">,</span> <span class="s2">&quot;stuff&quot;</span><span class="p">),</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">os</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;src/.config&quot;</span><span class="p">,</span> <span class="s2">&quot;src/.stuffconfig&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Here is the same thing done using the <code>pathlib</code> module:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/stuff&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/.config&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;src/.stuffconfig&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; PosixPath(&#39;src/.stuffconfig&#39;)
</code></pre></div>

<p>Notice the output where the renamed file path is printed. It's not a simple string,
rather a <code>PosixPath</code> object that indicates the type of host system (Linux in this case).
You can almost always use stringified path values and the Path objects interchangeably.</p>
<h2>Listing specific types of files in a directory</h2>
<p>Let's say you want to recursively visit nested directories and list <code>.py</code> files in a
directroy called source. The directory looks like this:</p>
<div class="highlight"><pre><span></span><code>src/
├── stuff
│   ├── __init__.py
│   └── submodule.py
├── .stuffconfig
├── somefiles.tar.gz
└── module.py
</code></pre></div>

<p>Usually, <code>glob</code> module is used to resolve this kind of situation:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>

<span class="n">top_level_py_files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="s2">&quot;src/*.py&quot;</span><span class="p">)</span>
<span class="n">all_py_files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="s2">&quot;src/**/*.py&quot;</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">top_level_py_files</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">all_py_files</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; [&#39;src/module.py&#39;]
&gt;&gt;&gt; [&#39;src/module.py&#39;, &#39;src/stuff/__init__.py&#39;, &#39;src/stuff/submodule.py&#39;]
</code></pre></div>

<p>The above approach works perfectly. However, if you don't want to use another module
just for a single job, <code>pathlib</code> has embedded <code>glob</code> and <code>rglob</code> methods. You can
entirely ignore glob and achieve the same result in the following way:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">top_level_py_files</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*.py&quot;</span><span class="p">)</span>
<span class="n">all_py_files</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rglob</span><span class="p">(</span><span class="s2">&quot;*.py&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">top_level_py_files</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">all_py_files</span><span class="p">))</span>
</code></pre></div>

<p>This will also print the same as before:</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; [PosixPath(&#39;src/module.py&#39;)]
&gt;&gt;&gt; [PosixPath(&#39;src/module.py&#39;),
    PosixPath(&#39;src/stuff/__init__.py&#39;),
    PosixPath(&#39;src/stuff/submodule.py&#39;)]
</code></pre></div>

<p>By default, both <code>Path.glob</code> and <code>Path.rglob</code> returns a generator object. Calling <code>list</code>
on them gives you the desired result. Notice how <code>rglob</code> method can discover the desired
files without you having to mention the directory structure with wildcards explicitly.
Pretty neat, huh?</p>
<h2>Opening multiple files &amp; reading their contents</h2>
<p>Now let's open the <code>.py</code> files and read their contents that you recursively discovered
in the previous example.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>

<span class="n">contents</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">glob</span><span class="p">(</span><span class="s2">&quot;src/**/*.py&quot;</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">contents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

<span class="nb">print</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; [&#39;from contextlib ...&#39;]
</code></pre></div>

<p>The <code>pathlib</code> implementation is almost identical as above.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">contents</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rglob</span><span class="p">(</span><span class="s2">&quot;*.py&quot;</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">contents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

<span class="nb">print</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="s1">&#39;from contextlib import ...&#39;</span><span class="p">]</span>
</code></pre></div>

<p>You can also cook up a more robust implementation with generator comprehension and
context manager.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">ExitStack</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="c1"># ExitStack ensures all files are properly closed after o/p</span>
<span class="k">with</span> <span class="n">ExitStack</span><span class="p">()</span> <span class="k">as</span> <span class="n">stack</span><span class="p">:</span>
    <span class="n">streams</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">enter_context</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rglob</span><span class="p">(</span><span class="s2">&quot;*.py&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">streams</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="s1">&#39;from contextlib import ...&#39;</span><span class="p">]</span>
</code></pre></div>

<h2>Anatomy of the pathlib module</h2>
<p>Primarily, <code>pathlib</code> has two high-level components, <code>pure path</code> and <code>concrete path</code>.
Pure paths are absolute <code>Path</code> objects that can be instantiated regardless of the host
operating system. On the other hand, to instantiate a concrete path, you need to be on
the specific type of host expected by the class. These two high level components are
made out of six individual classes internally coupled by inheritance. They are:</p>
<ol>
<li>PurePath (Useful when you want to work with windows path on a Linux machine)</li>
<li>PurePosixPath (Subclass of <code>PurePath</code>)</li>
<li>PureWindowsPath (Subclass of <code>PurePath</code>)</li>
<li>Path (Concrete path object, most of the time, you'll be dealing with this one)</li>
<li>PosixPath (Concrete posix path, subclass of <code>Path</code>)</li>
<li>WindowsPath (Concrete windows path, subclass of <code>Path</code>)</li>
</ol>
<p>This UML diagram from the official docs does a better job at explaining the internal
relationships between the component classes.</p>
<p align="center">
  <img src="https://docs.python.org/3/_images/pathlib-inheritance.png">
</p>

<p>Unless you are doing cross platform path manipulation, most of the time you'll be
working with the concrete <code>Path</code> object. So I'll focus on the methods and properties of
<code>Path</code> class only.</p>
<h3>Operators</h3>
<p>Instead of using <code>os.path.join</code> you can use <code>/</code> operator to create child paths.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">base_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">)</span>
<span class="n">child_dir</span> <span class="o">=</span> <span class="n">base_dir</span> <span class="o">/</span> <span class="s2">&quot;stuff&quot;</span>
<span class="n">file_path</span> <span class="o">=</span> <span class="n">child_dir</span> <span class="o">/</span> <span class="s2">&quot;__init__.py&quot;</span>

<span class="nb">print</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; PosixPath(&#39;src/stuff/__init__.py&#39;)
</code></pre></div>

<h3>Attributes &amp; methods</h3>
<p>The following tree shows an inexhaustive list of attributes and methods that are
associated with <code>Path</code> object. I have cherry picked some of the attributes and methods
that I use most of the time while doing path manipulation. Head over to the official
docs for a more detailed list. We'll linearly traverse through the tree and provide
necessary examples to grasp their usage.</p>
<div class="highlight"><pre><span></span><code>Path
│
├── Attributes
│       ├── parts
│       ├── parent &amp; parents
│       ├── name
│       ├── suffix &amp; suffixes
│       └── stem
│
│
└── Methods
        ├── joinpath(*other)
        ├── cwd()
        ├── home()
        ├── exists()
        ├── expanduser()
        ├── glob()
        ├── rglob(pattern)
        ├── is_dir()
        ├── is_file()
        ├── is_absolute()
        ├── iterdir()
        ├── mkdir(mode=0o777, parents=False, exist_ok=False)
        ├── open(mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None)
        ├── rename(target)
        ├── replace(target)
        ├── resolve(strict=False)
        └── rmdir()
</code></pre></div>

<p>Let's dive into their usage one by one. For all the examples, We'll be using the
previously seen directory structure.</p>
<div class="highlight"><pre><span></span><code>src/
├── stuff
│   ├── __init__.py
│   └── submodule.py
├── .stuffconfig
├── somefile.tar.gz
└── module.py
</code></pre></div>

<h4>Path.parts</h4>
<p>Returns a tuple containing individual components of a path.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/stuff/__init__.py&quot;</span><span class="p">)</span>
<span class="n">file_path</span><span class="o">.</span><span class="n">parts</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; (&#39;src&#39;, &#39;stuff&#39;, &#39;__init__.py&#39;)
</code></pre></div>

<h4>Path.parents &amp; Path.parent</h4>
<p><code>Path.parents</code> returns an immutable sequence containing the all logical ancestors of the
path. While <code>Path.parent</code> returns the immediate predecessor of the path.</p>
<div class="highlight"><pre><span></span><code><span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/stuff/__init__.py&quot;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">file_path</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; src/stuff
... src
... .
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">file_path</span><span class="o">.</span><span class="n">parent</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; PosixPath(&#39;src/stuff&#39;)
</code></pre></div>

<h4>Path.name</h4>
<p>Returns the last component of a path as string. Usually used to extract file name from a
path.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/module.py&quot;</span><span class="p">)</span>
<span class="n">file_path</span><span class="o">.</span><span class="n">name</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; &#39;module.py&#39;
</code></pre></div>

<h4>Path.suffixes &amp; Path.suffix</h4>
<p><code>Path.suffixes</code> returns a list of extensions of the final component. <code>Path.suffix</code> only
returns the last extension.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/stuff/somefile.tar.gz&quot;</span><span class="p">)</span>
<span class="n">file_path</span><span class="o">.</span><span class="n">suffixes</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; [&#39;.tar&#39;, &#39;.gz&#39;]
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">file_path</span><span class="o">.</span><span class="n">suffix</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt;&#39;.gz&#39;
</code></pre></div>

<h4>Path.stem</h4>
<p>Returns the final path component without the suffix.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/stuff/somefile.tar.gz&quot;</span><span class="p">)</span>
<span class="n">file_path</span><span class="o">.</span><span class="n">stem</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; &#39;somefile.tar&#39;
</code></pre></div>

<h4>Path.is_absolute</h4>
<p>Checks if a path is absolute or not. Return boolean value.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/stuff/somefile.tar.gz&quot;</span><span class="p">)</span>
<span class="n">file_path</span><span class="o">.</span><span class="n">is_absolute</span><span class="p">()</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; False
</code></pre></div>

<h4>Path.joinpath(*other)</h4>
<p>This method is used to combine multiple components into a complete path. This can be
used as an alternative to <code>"/"</code> operator for joining path components.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s2">&quot;stuff&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s2">&quot;__init__.py&quot;</span><span class="p">)</span>
<span class="n">file_path</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; PosixPath(&#39;src/stuff/__init__.py&#39;)
</code></pre></div>

<h4>Path.cwd()</h4>
<p>Returns the current working directory.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/stuff/somefile.tar.gz&quot;</span><span class="p">)</span>
<span class="n">file_path</span><span class="o">.</span><span class="n">cwd</span><span class="p">()</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; PosixPath(&#39;/home/rednafi/code/demo&#39;)
</code></pre></div>

<h4>Path.home()</h4>
<p>Returns home directory.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">Path</span><span class="o">.</span><span class="n">home</span><span class="p">()</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; PosixPath(&#39;/home/rednafi&#39;)
</code></pre></div>

<h4>Path.exists()</h4>
<p>Checks if a path exists or not. Returns boolean value.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/stuff/thisisabsent.py&quot;</span><span class="p">)</span>
<span class="n">file_path</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; False
</code></pre></div>

<h4>Path.expanduser()</h4>
<p>Returns a new path with expanded <code>~</code> symbol.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;~/code/demo/src/stuff/somefile.tar.gz&quot;</span><span class="p">)</span>
<span class="n">file_path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">()</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; PosixPath(&#39;/home/rednafi/code/demo/src/stuff/somefile.tar.gz&#39;)
</code></pre></div>

<h4>Path.glob()</h4>
<p>Globs and yields all file paths matching a specific pattern. Let's discover all the
files in <code>src/stuff/</code> directory that have <code>.py</code> extension.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">dir_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/stuff/&quot;</span><span class="p">)</span>
<span class="n">file_paths</span> <span class="o">=</span> <span class="n">dir_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*.py&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">file_paths</span><span class="p">))</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; [PosixPath(&#39;src/stuff/__init__.py&#39;), PosixPath(&#39;src/stuff/submodule.py&#39;)]
</code></pre></div>

<h4>Path.rglob(pattern)</h4>
<p>This is like <code>Path.glob</code> method but matches the file pattern recursively.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">dir_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">)</span>
<span class="n">file_paths</span> <span class="o">=</span> <span class="n">dir_path</span><span class="o">.</span><span class="n">rglob</span><span class="p">(</span><span class="s2">&quot;*.py&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">file_paths</span><span class="p">))</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; [PosixPath(&#39;src/module.py&#39;),
    PosixPath(&#39;src/stuff/__init__.py&#39;),
    PosixPath(&#39;src/stuff/submodule.py&#39;)]
</code></pre></div>

<h4>Path.is_dir()</h4>
<p>Checks if a path points to a directory or not. Returns boolean value.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">dir_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/stuff/&quot;</span><span class="p">)</span>
<span class="n">dir_path</span><span class="o">.</span><span class="n">is_dir</span><span class="p">()</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; True
</code></pre></div>

<h4>Path.is_file()</h4>
<p>Checks if a path points to a file. Returns boolean value.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">dir_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/stuff/&quot;</span><span class="p">)</span>
<span class="n">dir_path</span><span class="o">.</span><span class="n">is_file</span><span class="p">()</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; False
</code></pre></div>

<h4>Path.is_absolute()</h4>
<p>Checks if a path is absolute or relative. Returns boolean value.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">dir_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/stuff/&quot;</span><span class="p">)</span>
<span class="n">dir_path</span><span class="o">.</span><span class="n">is_absolute</span><span class="p">()</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; False
</code></pre></div>

<h4>Path.iterdir()</h4>
<p>When the path points to a directory, this yields the content path objects.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">base_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src&quot;</span><span class="p">)</span>
<span class="n">contents</span> <span class="o">=</span> <span class="p">[</span><span class="n">content</span> <span class="k">for</span> <span class="n">content</span> <span class="ow">in</span> <span class="n">base_path</span><span class="o">.</span><span class="n">iterdir</span><span class="p">()]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; [PosixPath(&#39;src/stuff&#39;),
     PosixPath(&#39;src/module.py&#39;),
     PosixPath(&#39;src/.stuffconfig&#39;)]
</code></pre></div>

<h4>Path.mkdir(mode=0o777, parents=False, exist_ok=False)</h4>
<p>Creates a new directory at this given path.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p><strong>mode:</strong>(<em>str</em>) Posix permissions (mimicking the POSIX mkdir -p command)</p>
</li>
<li>
<p><strong>parents:</strong>(<em>boolean</em>) If parents is <code>True</code>, any missing parents of this path are
created as needed. Otherwise, if the parent is absent, <code>FileNotFoundError</code> is raised.</p>
</li>
<li>
<p><strong>exist_ok:</strong> (<em>boolean</em>) If <code>False</code>, FileExistsError is raised if the target
directory already exists. If <code>True</code>, FileExistsError is ignored.</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">dir_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/other/side&quot;</span><span class="p">)</span>
<span class="n">dir_path</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</code></pre></div>

<h4>Path.open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)</h4>
<p>This is same as the built in <code>open</code> function.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="k">with</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/module.py&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">contents</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">contents</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span>
<span class="o">...</span> <span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
<span class="o">...</span> <span class="o">.....</span>
</code></pre></div>

<h4>Path.rename(target)</h4>
<p>Renames this file or directory to the given target and returns a new Path instance
pointing to target. This will raise <code>FileNotFoundError</code> if the file is not found.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/stuff/submodule.py&quot;</span><span class="p">)</span>
<span class="n">file_path</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">file_path</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="s2">&quot;anothermodule.py&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; PosixPath(&#39;src/stuff/anothermodule.py&#39;)
</code></pre></div>

<h4>Path.replace(target)</h4>
<p>Replaces a file or directory to the given target. Returns the new path instance.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/stuff/anothermodule.py&quot;</span><span class="p">)</span>
<span class="n">file_path</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">file_path</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="s2">&quot;Dockerfile&quot;</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; PosixPath(&#39;src/stuff/Dockerfile&#39;)
</code></pre></div>

<h4>Path.resolve(strict=False)</h4>
<p>Make the path absolute, resolving any symlinks. A new path object is returned. If strict
is <code>True</code> and the path doesn't exist, <code>FileNotFoundError</code> will be raised.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/./stuff/Dockerfile&quot;</span><span class="p">)</span>
<span class="n">file_path</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; PosixPath(&#39;/home/rednafi/code/demo/src/stuff/Dockerfile&#39;)
</code></pre></div>

<h4>Path.rmdir()</h4>
<p>Removes a path pointing to a file or directory. The directory must be empty, otherwise,
<code>OSError</code> is raised.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;src/stuff&quot;</span><span class="p">)</span>
<span class="n">file_path</span><span class="o">.</span><span class="n">rmdir</span><span class="p">()</span>
</code></pre></div>

<h2>So, should you use it?</h2>
<p>Pathlib was introduced in python 3.4. However, if you are working with python 3.5 or
earlier, in some special cases, you might have to convert <code>pathlib.Path</code> objects to
regular strings. But since python 3.6, <code>Path</code> objects work almost everywhere you are
using stringified paths. Also, the <code>Path</code> object nicely abstracts away the complexity
that arises while working with paths in different operating systems.</p>
<p>The ability to manipulate paths in an OO way and not having to rummage through the
massive <code>os</code> or <code>shutil</code> module can make path manipulation a lot less painful.</p>
<h2>References</h2>
<ul>
<li><a href="https://docs.python.org/3/library/pathlib.html">pathlib — Object-oriented filesystem paths</a></li>
<li><a href="https://realpython.com/python-pathlib/">Python 3's pathlib Module: Taming the File System</a></li>
<li><a href="https://treyhunner.com/2018/12/why-you-should-be-using-pathlib/#The_os_module_is_crowded">Why you should be using pathlib</a></li>
</ul>


             
 
            
            
            







            <hr/>
        </div>
        <section id="article-sidebar" class="span2">
            <h4>Published</h4>
            <time itemprop="dateCreated" datetime="2020-04-13T00:00:00+06:00">Mon 13 April 2020</time>
            <h4>Category</h4>
            <a class="category-link" href="./categories.html#python-ref">python</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="./tags.html#python-ref">Python
                    <span class="superscript">58</span>
</a></li>
            </ul>
<h4>Contact</h4>
<div id="sidebar-social-link">
    <a href="mailto:redowan.nafi@gmail.com" title="" target="_blank" rel="nofollow noopener noreferrer">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="Mail" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#328cff"/><path d="m250 186c-46 0-69 35-69 74 0 44 29 72 68 72 43 0 73-32 73-75 0-44-34-71-72-71zm-1-37c30 0 57 13 77 33 0-22 35-22 35 1v150c-1 10 10 16 16 9 25-25 54-128-14-187-64-56-149-47-195-15-48 33-79 107-49 175 33 76 126 99 182 76 28-12 41 26 12 39-45 19-168 17-225-82-38-68-36-185 67-248 78-46 182-33 244 32 66 69 62 197-2 246-28 23-71 1-71-32v-11c-20 20-47 32-77 32-57 0-108-51-108-108 0-58 51-110 108-110" fill="#fff"/></svg>
    </a>
    <a href="https://github.com/rednafi" title="" target="_blank" rel="nofollow noopener noreferrer">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="GitHub" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#1B1817"/><path fill="#fff" d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
    </a>
    <a href="https://twitter.com/rednafi" title="" target="_blank" rel="nofollow noopener noreferrer">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="Twitter" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#1da1f3"/><path fill="#fff" d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
    </a>
    <a href="https://www.goodreads.com/user/show/53485837-redowan-delowar" title="" target="_blank" rel="nofollow noopener noreferrer">
        <svg height="512" viewBox="0 0 512 512" width="512" xmlns="http://www.w3.org/2000/svg"><rect fill="#EAE6CF" height="512" rx="64" width="512"/><path d="m254.92444 336.92444c43.2889-.36 74.07112-22.01333 92.33334-64.95111h.95556v65.48889c0 4.88-.32 12.44889-.95556 22.73333-1.30222 10.64445-4.78222 22.10223-10.42666 34.36889-5.65778 11.54667-14.79112 21.38667-27.37778 29.49778-12.44889 8.84-29.81778 13.44-52.12001 13.80444-21.48444 0-39.65333-5.59555-54.52444-16.77777-15.2-11.00889-24.08001-28.87111-26.65778-53.58667h-18.89778c1.93778 32.11111 12.18667 55.02667 30.76444 68.74222 18.08889 13.16445 41.04001 19.75556 68.83556 19.75556 27.45778 0 48.87112-5.14223 64.21778-15.43111 15.18223-9.92 26.08445-22.28445 32.71556-37.08 6.62222-14.79111 10.58222-28.86667 11.86667-42.21334.98222-13.35555 1.45778-22.91555 1.45778-28.68889v-270.088875h-18.90667v59.537775h-.95556c-7.27555-21.82667-19.30666-38.333335-36.12-49.524445-16.96-11.00445-35.70222-16.51111-56.21333-16.51111-35.72001.72444-62.85779 14.52444-81.43112 41.40889-19.07111 26.697775-28.59556 59.631105-28.59556 98.782195 0 40.23557 9.04445 73.52001 27.13334 99.86224 18.27555 26.88889 45.89778 40.51111 82.90222 40.87111zm-68.34222-224.89777c14.85333-24.359995 37.63111-36.986665 68.34222-37.888885 31.50223.90666 54.83556 13.17333 70.03556 36.808885 15.18223 23.64 22.77778 52.05331 22.77778 85.25331s-7.59555 61.43112-22.77778 84.70668c-15.2 24.72444-38.53333 37.34667-70.03556 37.88889-29.72889-.54667-52.36-12.81778-67.86222-36.80889-15.67556-23.27556-23.50667-51.87112-23.50667-85.79112-.004-31.75556 7.67111-59.81332 23.02667-84.16887z" fill="#743901"/></svg>
    </a>
    <a href="/reflections/feeds/all.atom.xml" title="" target="_blank" rel="nofollow noopener noreferrer">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="RSS" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#f80"/><circle cx="145" cy="367" r="35" fill="#fff"/><path fill="none" stroke="#fff" stroke-width="60" d="M109 241c89 0 162 73 162 162M109 127c152 0 276 124 276 276"/></svg>
    </a>
</div>
            





            





        </section>
</div>
</article>
<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides.
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>                    </div>
                    <div class="span1"></div>
                </div>
            </div>
        </div>
<footer>



    <div id="fpowered">

            © 2020-2022 • Redowan Delowar • All Rights Reserved


    </div>
</footer>            <script src="//code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script src="./theme/js/elegant.prod.9e9d5ce754.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    <script>
    (function () {
        if (window.location.hash.match(/^#comment-\d+$/)) {
            $('#comment_thread').collapse('show');
        }
    })();
    window.onhashchange=function(){
        if (window.location.hash.match(/^#comment-\d+$/))
            window.location.reload(true);
    }
    $('#comment_thread').on('shown', function () {
        var link = document.getElementById('comment-accordion-toggle');
        var old_innerHTML = link.innerHTML;
        $(link).fadeOut(200, function() {
            $(this).text('Click here to hide comments').fadeIn(200);
        });
        $('#comment_thread').on('hidden', function () {
            $(link).fadeOut(200, function() {
                $(this).text(old_innerHTML).fadeIn(200);
            });
        })
    })
</script>

    </body>
    <!-- Theme: Elegant built for Pelican
        License : MIT -->
</html>